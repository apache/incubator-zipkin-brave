package brave.druid;

import brave.ScopedSpan;
import brave.Tracing;
import brave.propagation.ThreadLocalCurrentTraceContext;
import brave.propagation.ThreadLocalSpan;
import brave.sampler.Sampler;
import com.alibaba.druid.filter.Filter;
import com.alibaba.druid.pool.DruidDataSource;
import com.mysql.jdbc.jdbc2.optional.MysqlDataSource;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.mockito.junit.MockitoJUnitRunner;
import zipkin2.Span;

import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.entry;
import static org.junit.Assume.assumeTrue;

/**
 *
 */
public class ITTracingStatementFilterTest {

    static final String QUERY = " create tableT_SC_LOG(LOG_ID               INTEGER NOT NULL GENERATED BYDEFAULT AS IDENTITY (START WITH 100, INCREMENT BY 1),LOG_TYPE             VARCHAR(8))";

    /** JDBC is synchronous and we aren't using thread pools: everything happens on the main thread */
    ArrayList<Span> spans = new ArrayList<>();

    Tracing tracing = tracingBuilder(Sampler.ALWAYS_SAMPLE).build();
    Connection connection;

    @Before
    public void init() throws SQLException {


        DruidDataSource druidDataSource = new DruidDataSource();
        druidDataSource.setLoginTimeout(5);
        druidDataSource.setKillWhenSocketReadTimeout(true);
        druidDataSource.setUrl("jdbc:derby:memory:test;create=true");

        List<Filter> filters = new ArrayList<>();
        TracingStatementFilter tracingStatementFilter = new TracingStatementFilter("testServer");
        filters.add(tracingStatementFilter);

        druidDataSource.setProxyFilters(filters);

        connection = druidDataSource.getConnection();
        spans.clear();
    }

    @After public void close() throws SQLException {
        Tracing.current().close();
        if (connection != null) connection.close();
    }

    @Test
    public void makesChildOfCurrentSpan() throws Exception {
        ScopedSpan parent = tracing.tracer().startScopedSpan("test");
        try {
            prepareExecuteSelect(QUERY);
        } finally {
            parent.finish();
        }

    }



    void prepareExecuteSelect(String query) throws SQLException {
            try{
                PreparedStatement ps = connection.prepareStatement(query);
                ResultSet resultSet = ps.executeQuery();

            }catch (Exception e){

            }
    }

    Tracing.Builder tracingBuilder(Sampler sampler) {
        return Tracing.newBuilder()
                .spanReporter(spans::add)
                .currentTraceContext(ThreadLocalCurrentTraceContext.create())
                .sampler(sampler);
    }

    static int envOr(String key, int fallback) {
        return System.getenv(key) != null ? Integer.parseInt(System.getenv(key)) : fallback;
    }

    static String envOr(String key, String fallback) {
        return System.getenv(key) != null ? System.getenv(key) : fallback;
    }
}

